uav_number=2 #początkowa liczba dronów w symulacji. mozliwe wartości to 1,2
hands_number=2 #liczba rąk w symulacji. mozliwe wartości to 0,1,2
visualization=1 #czy ma być widoczna wizualizacja. 0: brak wizualizacji, 1: jest wizualizacja,2 jest wizaulizacja i zapis do pliku
T=500 #liczba jednostek czasu, do zakończenia symulacji. wartości powyżej 0
mode=normal operating #tryby wyszukiwania trasy przez drona. możliwe wartości: RW-RA, normal operating, annealing
prob_of_attack=0.7 #Prawdopodobieństwo wykonania ataku w trybie losowym(dotyczy trybu exploitation1). wartości od 0 do 1
prob_of_return_to_T2=0.1 #Parwdopodobieństwo powrotu na tier2. wartośc od 0 do 1(dotyczy wszaystkich trybów)
tier1_distance_from_intruder=400 #Odległość tier1 od intruza. wartosci powyżej 0
v_of_uav=15 #Prędkośći drona. wartosci powyżej 0
wait_time=0.3 #Czas oczekiwania dla zdarzenia wait. wartośc powyżej 0
uav_size=10 #Rozmiar UAV. wartośc powyżej 0
hand_size=20 #Rozmiar ręki. wartość powyżej 0
velocity_hand=10 #Prędkość ręki. wartość powyżej 0
visualzation_update_interval=0.5 #co ile jednostek czasu ma być aktualizowana wizualizacja symulacji. Wartość powyżej 0
r_of_LR=300 #Maksymalny zasięg ręki. wartość powyżej 0. r_of_LR musi być większe niż suma intuder_size i uav_size
map_resolution=3 #Rozdzielczość mapy tworzonej na potrzeby algorytmu poszukującego ścieżki. wartość powyżej 0
seed_clock=0 #możliwe wartości: 1 seed jest wybierany z zegara, 0: wartość seed jest ustawionan w pliku konf(we właściwość seed)
seed=250 #ziarno generatora liczb losowych
intuder_size=120 #rozmiar intruza
mode_debug=0 #tryb debug w jakim działa program. możliwe wartości: 0 SA1(tryb normalny), 1 debug A0, 2 debug A1, 3 debug SA0, 4 debug SA0
time_to_wait_after_jump=20 #jak długo ręka musi czekać po wykonaniu skoku
jump_ratio=2 # ile razy ręka przyspiesza(ilu krotnie ręka zwiększa swoją prędkość) podczas skoku
blind_angle=20 # wyrażony w stopniach maksymalny kąt pomiędzy uav, przy którm intruz jest zdolny do jednoczesnej reakcji na działania obydwu uav
intruder_time_of_reaction=5 # czas co jaki intruz aktualizuje swoją strategie
hand_max_deviation=20 #maksymalny błąd występujący przy wykonywaniu skoku przez ręke(jeśli bład=0 ręka będzie celowała idealnie w pozycje drona)
visualisation_speed=1 #im wyższa wartość tym wolniej symulacja działa(wygodna do obserwacji wartośc to ponad 30)
tier2_mode=0 # możliwe wartości: 1 uav po każdym ataku będzie przechodził na tier2, 0 uav będzie mógł poruszać się zarówno po Tier1 jak i Tier2
naive algo list limit=10 #pojemność pamięci w algorytmie normal operating
temperature=1000000 #temperatura z algorytmu wyżarzania
temperature_reduction=0.7 # alpha czyli współczynnik redukcji temperatury algorytmu wyżarzania
annealing_number_of_iterations=50 #liczba iteracji w algorytmie wyżarzania
is_multirun=0 #czy ma zostać uruchomiony multirun. mozliwe wartości: 0 normalne uruchominie algorytmu(bez multiruna) 1 multirun
number_of_runs=2 #gdy multirun aktywny okresla liczbe odpaleń algorytmu
iterations_for_learning=50 #liczba iteracji po której osiągnięciu kończy się proces uczenia w algorytmie normalnego wykonania
zone_width=50 #szerokość strefy(strefy są używane w pamięci algorytmu normalnego wykonania)
uav_energy_consumption=2 # zużycie energi uav na jednostke czasu
uav_energy=3 #poczatkowa energia uav
intruder_energy=3 #poczatkowa energia intruza
intruder_energy_consumption=2 # zużycie energi intruza na jednostke czasu
energy_simulation_end_condition=0 #czy symulacja zakonczy sie gdy energia intruza wyniesie 0. mozliwe wartości 1: warunek będzie brany pod uwagę, 0: warunek nie będzie brany pod uwagę
drone_energy_destroy_condition=0 #czy drony będą niszczone gdy wyczerpie się ich energia. mozliwe wartości 1: warunek będzie brany pod uwagę, 0: warunek ni będzie brany pod uwagę
fake_targets_number=3 #liczba celów z listy które będą zaatakowane bo wykonaniu ataku na najlepszy cel z listy w algorytmie normalnego wykonania
load_memory=0 #czy ma być używana pamięć zapisana w pliku. możlwe wartośći 0: nie będzie używana pamięć z pliku 1: będzie używana pamięć z pliku
map_size_x=1040 #szerokość mapy
